{"ast":null,"code":"import { __decorate, __param } from 'tslib';\nimport { ElementRef, Inject, PLATFORM_ID, Injectable, Renderer2, Input, Directive, NgModule } from '@angular/core';\nimport { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport { ReplaySubject, throwError } from 'rxjs';\n/** Default values for Component Input */\n\nimport * as ɵngcc0 from '@angular/core';\nconst DEFAULTS = {\n  target: null,\n  action: 'click',\n  duration: 650,\n  easing: 'easeInOutQuad',\n  offset: 0,\n  offsetMap: new Map()\n};\n\nconst ɵ0 = time => {\n  return time * time;\n},\n      ɵ1 = time => {\n  return time * (2 - time);\n},\n      ɵ2 = time => {\n  return time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time;\n},\n      ɵ3 = time => {\n  return time * time * time;\n},\n      ɵ4 = time => {\n  return --time * time * time + 1;\n},\n      ɵ5 = time => {\n  return time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;\n},\n      ɵ6 = time => {\n  return time * time * time * time;\n},\n      ɵ7 = time => {\n  return 1 - --time * time * time * time;\n},\n      ɵ8 = time => {\n  return time < 0.5 ? 8 * time * time * time * time : 1 - 8 * --time * time * time * time;\n},\n      ɵ9 = time => {\n  return time * time * time * time * time;\n},\n      ɵ10 = time => {\n  return 1 + --time * time * time * time * time;\n},\n      ɵ11 = time => {\n  return time < 0.5 ? 16 * time * time * time * time * time : 1 + 16 * --time * time * time * time * time;\n},\n      ɵ12 = time => {\n  return Math.pow(2, -10 * time) * Math.sin((time - 1 / 4) * (2 * Math.PI) / 1) + 1;\n};\n/** Easing Colleciton */\n\n\nconst EASING = {\n  easeInQuad: ɵ0,\n  easeOutQuad: ɵ1,\n  easeInOutQuad: ɵ2,\n  easeInCubic: ɵ3,\n  easeOutCubic: ɵ4,\n  easeInOutCubic: ɵ5,\n  easeInQuart: ɵ6,\n  easeOutQuart: ɵ7,\n  easeInOutQuart: ɵ8,\n  easeInQuint: ɵ9,\n  easeOutQuint: ɵ10,\n  easeInOutQuint: ɵ11,\n  easeOutElastic: ɵ12\n};\n/**\n * Set of allowed events as triggers\n * for the Animation to start.\n */\n\nconst EVENTS = ['click', 'mouseenter', 'mouseover', 'mousedown', 'mouseup', 'dblclick', 'contextmenu', 'wheel', 'mouseleave', 'mouseout'];\n/**\n * Strip hash (#) from value.\n *\n * @param value \t\t\t\tThe given string value\n * @returns \t\t\t\t\tThe stripped string value\n */\n\nfunction stripHash(value) {\n  return value.substring(0, 1) === '#' ? value.substring(1) : value;\n}\n/**\n * Test if a given value is a string.\n *\n * @param value \t\t\t\t\tThe given value\n * @returns \t\t\t\t\t\tWhether the given value is a string\n */\n\n\nfunction isString(value) {\n  return typeof value === 'string' || value instanceof String;\n}\n/**\n * Test if a given Element is the Window.\n *\n * @param container \t\t\t\tThe given Element\n * @returns \t\t\t\t\t\tWhether the given Element is Window\n */\n\n\nfunction isWindow(container) {\n  return container === window;\n}\n/**\n * Test if a given value is of type ElementRef.\n *\n * @param value \t\t\t\t\tThe given value\n * @returns               Whether the given value is a number\n */\n\n\nfunction isElementRef(value) {\n  return value instanceof ElementRef;\n}\n/**\n * Whether or not the given value is a Native Element.\n *\n * @param value           The given value\n * @returns               Whether or not the value is a Native Element\n */\n\n\nfunction isNativeElement(value) {\n  return value instanceof HTMLElement;\n}\n/**\n * Test if a given value is type number.\n *\n * @param value \t\t\t\t\tThe given value\n * @returns \t\t\t\t\t\tWhether the given value is a number\n */\n\n\nfunction isNumber(value) {\n  return !isNaN(parseFloat(value)) && isFinite(value);\n}\n/** Scroll To Animation */\n\n\nclass ScrollToAnimation {\n  /**\n   * Class Constructor.\n   *\n   * @param container            The Container\n   * @param listenerTarget       The Element that listens for DOM Events\n   * @param isWindow             Whether or not the listener is the Window\n   * @param to                   Position to scroll to\n   * @param options              Additional options for scrolling\n   * @param isBrowser            Whether or not execution runs in the browser\n   *                              (as opposed to the server)\n   */\n  constructor(container, listenerTarget, isWindow, to, options, isBrowser) {\n    this.container = container;\n    this.listenerTarget = listenerTarget;\n    this.isWindow = isWindow;\n    this.to = to;\n    this.options = options;\n    this.isBrowser = isBrowser;\n    /** Recursively loop over the Scroll Animation */\n\n    this.loop = () => {\n      this.timeLapsed += this.tick;\n      this.percentage = this.timeLapsed / this.options.duration;\n      this.percentage = this.percentage > 1 ? 1 : this.percentage; // Position Update\n\n      this.position = this.startPosition + (this.startPosition - this.to <= 0 ? 1 : -1) * this.distance * EASING[this.options.easing](this.percentage);\n\n      if (this.lastPosition !== null && this.position === this.lastPosition) {\n        this.stop();\n      } else {\n        this.source$.next(this.position);\n        this.isWindow ? this.listenerTarget.scrollTo(0, Math.floor(this.position)) : this.container.scrollTop = Math.floor(this.position);\n        this.lastPosition = this.position;\n      }\n    };\n\n    this.tick = 16;\n    this.interval = null;\n    this.lastPosition = null;\n    this.timeLapsed = 0;\n    this.windowScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\n\n    if (!this.container) {\n      this.startPosition = this.windowScrollTop;\n    } else {\n      this.startPosition = this.isWindow ? this.windowScrollTop : this.container.scrollTop;\n    } // Correction for Starting Position of nested HTML Elements\n\n\n    if (this.container && !this.isWindow) {\n      this.to = this.to - this.container.getBoundingClientRect().top + this.startPosition;\n    } // Set Distance\n\n\n    const directionalDistance = this.startPosition - this.to;\n    this.distance = this.container ? Math.abs(this.startPosition - this.to) : this.to;\n    this.mappedOffset = this.options.offset; // Set offset from Offset Map\n\n    if (this.isBrowser) {\n      this.options.offsetMap.forEach((value, key) => this.mappedOffset = window.innerWidth > key ? value : this.mappedOffset);\n    }\n\n    this.distance += this.mappedOffset * (directionalDistance <= 0 ? 1 : -1);\n    this.source$ = new ReplaySubject();\n  }\n  /**\n   * Start the new Scroll Animation.\n   *\n   * @returns         Observable containing a number\n   */\n\n\n  start() {\n    clearInterval(this.interval);\n    this.interval = setInterval(this.loop, this.tick);\n    return this.source$.asObservable();\n  }\n  /**\n   * Stop the current Scroll Animation Loop.\n   *\n   * @param force          Force to stop the Animation Loop\n   * @returns               Void\n   */\n\n\n  stop() {\n    clearInterval(this.interval);\n    this.interval = null;\n    this.source$.complete();\n  }\n\n}\n/**\n * The Scroll To Service handles starting, interrupting\n * and ending the actual Scroll Animation. It provides\n * some utilities to find the proper HTML Element on a\n * given page to setup Event Listeners and calculate\n * distances for the Animation.\n */\n\n\nlet ScrollToService = class ScrollToService {\n  /**\n   * Construct and setup required paratemeters.\n   *\n   * @param document         A Reference to the Document\n   * @param platformId       Angular Platform ID\n   */\n  constructor(document, platformId) {\n    this.document = document;\n    this.platformId = platformId;\n    this.interruptiveEvents = ['mousewheel', 'DOMMouseScroll', 'touchstart'];\n  }\n  /**\n   * Target an Element to scroll to. Notice that the `TimeOut` decorator\n   * ensures the executing to take place in the next Angular lifecycle.\n   * This allows for scrolling to elements that are e.g. initially hidden\n   * by means of `*ngIf`, but ought to be scrolled to eventually.\n   *\n   * @todo type 'any' in Observable should become custom type like 'ScrollToEvent' (base class), see issue comment:\n   *  - https://github.com/nicky-lenaers/ngx-scroll-to/issues/10#issuecomment-317198481\n   *\n   * @param options         Configuration Object\n   * @returns               Observable\n   */\n\n\n  scrollTo(options) {\n    if (!isPlatformBrowser(this.platformId)) {\n      return new ReplaySubject().asObservable();\n    }\n\n    return this.start(options);\n  }\n  /**\n   * Start a new Animation.\n   *\n   * @todo Emit proper events from subscription\n   *\n   * @param options         Configuration Object\n   * @returns               Observable\n   */\n\n\n  start(options) {\n    // Merge config with default values\n    const mergedConfigOptions = Object.assign(Object.assign({}, DEFAULTS), options);\n\n    if (this.animation) {\n      this.animation.stop();\n    }\n\n    const targetNode = this.getNode(mergedConfigOptions.target);\n\n    if (mergedConfigOptions.target && !targetNode) {\n      return throwError('Unable to find Target Element');\n    }\n\n    const container = this.getContainer(mergedConfigOptions, targetNode);\n\n    if (mergedConfigOptions.container && !container) {\n      return throwError('Unable to find Container Element');\n    }\n\n    const listenerTarget = this.getListenerTarget(container) || window;\n    let to = container ? container.getBoundingClientRect().top : 0;\n\n    if (targetNode) {\n      to = isWindow(listenerTarget) ? window.scrollY + targetNode.getBoundingClientRect().top : targetNode.getBoundingClientRect().top;\n    } // Create Animation\n\n\n    this.animation = new ScrollToAnimation(container, listenerTarget, isWindow(listenerTarget), to, mergedConfigOptions, isPlatformBrowser(this.platformId));\n\n    const onInterrupt = () => this.animation.stop();\n\n    this.addInterruptiveEventListeners(listenerTarget, onInterrupt); // Start Animation\n\n    const animation$ = this.animation.start();\n    this.subscribeToAnimation(animation$, listenerTarget, onInterrupt);\n    return animation$;\n  }\n  /**\n   * Subscribe to the events emitted from the Scrolling\n   * Animation. Events might be used for e.g. unsubscribing\n   * once finished.\n   *\n   * @param animation$              The Animation Observable\n   * @param listenerTarget          The Listener Target for events\n   * @param onInterrupt             The handler for Interruptive Events\n   * @returns                       Void\n   */\n\n\n  subscribeToAnimation(animation$, listenerTarget, onInterrupt) {\n    const subscription = animation$.subscribe(() => {}, () => {}, () => {\n      this.removeInterruptiveEventListeners(this.interruptiveEvents, listenerTarget, onInterrupt);\n      subscription.unsubscribe();\n    });\n  }\n  /**\n   * Get the container HTML Element in which\n   * the scrolling should happen.\n   *\n   * @param options         The Merged Configuration Object\n   * @param targetNode    the targeted HTMLElement\n   */\n\n\n  getContainer(options, targetNode) {\n    let container = null;\n\n    if (options.container) {\n      container = this.getNode(options.container, true);\n    } else if (targetNode) {\n      container = this.getFirstScrollableParent(targetNode);\n    }\n\n    return container;\n  }\n  /**\n   * Add listeners for the Animation Interruptive Events\n   * to the Listener Target.\n   *\n   * @param events            List of events to listen to\n   * @param listenerTarget    Target to attach the listener on\n   * @param handler           Handler for when the listener fires\n   * @returns                 Void\n   */\n\n\n  addInterruptiveEventListeners(listenerTarget, handler) {\n    if (!listenerTarget) {\n      listenerTarget = window;\n    }\n\n    this.interruptiveEvents.forEach(event => listenerTarget.addEventListener(event, handler, this.supportPassive() ? {\n      passive: true\n    } : false));\n  }\n  /**\n   * Feature-detect support for passive event listeners.\n   *\n   * @returns       Whether or not passive event listeners are supported\n   */\n\n\n  supportPassive() {\n    let supportsPassive = false;\n\n    try {\n      const opts = Object.defineProperty({}, 'passive', {\n        get: () => {\n          supportsPassive = true;\n        }\n      });\n      window.addEventListener('testPassive', null, opts);\n      window.removeEventListener('testPassive', null, opts);\n    } catch (e) {}\n\n    return supportsPassive;\n  }\n  /**\n   * Remove listeners for the Animation Interrupt Event from\n   * the Listener Target. Specifying the correct handler prevents\n   * memory leaks and makes the allocated memory available for\n   * Garbage Collection.\n   *\n   * @param events            List of Interruptive Events to remove\n   * @param listenerTarget    Target to attach the listener on\n   * @param handler           Handler for when the listener fires\n   * @returns                 Void\n   */\n\n\n  removeInterruptiveEventListeners(events, listenerTarget, handler) {\n    if (!listenerTarget) {\n      listenerTarget = window;\n    }\n\n    events.forEach(event => listenerTarget.removeEventListener(event, handler));\n  }\n  /**\n   * Find the first scrollable parent Node of a given\n   * Element. The DOM Tree gets searched upwards\n   * to find this first scrollable parent. Parents might\n   * be ignored by CSS styles applied to the HTML Element.\n   *\n   * @param nativeElement     The Element to search the DOM Tree upwards from\n   * @returns                 The first scrollable parent HTML Element\n   */\n\n\n  getFirstScrollableParent(nativeElement) {\n    let style = window.getComputedStyle(nativeElement);\n    const overflowRegex = /(auto|scroll|overlay)/;\n\n    if (style.position === 'fixed') {\n      return null;\n    }\n\n    let parent = nativeElement;\n\n    while (parent.parentElement) {\n      parent = parent.parentElement;\n      style = window.getComputedStyle(parent);\n\n      if (style.position === 'absolute' || style.overflow === 'hidden' || style.overflowY === 'hidden') {\n        continue;\n      }\n\n      if (overflowRegex.test(style.overflow + style.overflowY) || parent.tagName === 'BODY') {\n        return parent;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Get the Target Node to scroll to.\n   *\n   * @param id              The given ID of the node, either a string or\n   *                        an element reference\n   * @param allowBodyTag    Indicate whether or not the Document Body is\n   *                        considered a valid Target Node\n   * @returns               The Target Node to scroll to\n   */\n\n\n  getNode(id, allowBodyTag = false) {\n    let targetNode;\n\n    if (isString(id)) {\n      if (allowBodyTag && (id === 'body' || id === 'BODY')) {\n        targetNode = this.document.body;\n      } else {\n        targetNode = this.document.getElementById(stripHash(id));\n      }\n    } else if (isNumber(id)) {\n      targetNode = this.document.getElementById(String(id));\n    } else if (isElementRef(id)) {\n      targetNode = id.nativeElement;\n    } else if (isNativeElement(id)) {\n      targetNode = id;\n    }\n\n    return targetNode;\n  }\n  /**\n   * Retrieve the Listener target. This Listener Target is used\n   * to attach Event Listeners on. In case of the target being\n   * the Document Body, we need the actual `window` to listen\n   * for events.\n   *\n   * @param container           The HTML Container element\n   * @returns                   The Listener Target to attach events on\n   */\n\n\n  getListenerTarget(container) {\n    if (!container) {\n      return null;\n    }\n\n    return this.isDocumentBody(container) ? window : container;\n  }\n  /**\n   * Test if a given HTML Element is the Document Body.\n   *\n   * @param element             The given HTML Element\n   * @returns                   Whether or not the Element is the\n   *                            Document Body Element\n   */\n\n\n  isDocumentBody(element) {\n    return element.tagName.toUpperCase() === 'BODY';\n  }\n\n};\n\nScrollToService.ɵfac = function ScrollToService_Factory(t) {\n  return new (t || ScrollToService)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(PLATFORM_ID));\n};\n\nScrollToService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: ScrollToService,\n  factory: function (t) {\n    return ScrollToService.ɵfac(t);\n  }\n});\n\nScrollToService.ctorParameters = () => [{\n  type: undefined,\n  decorators: [{\n    type: Inject,\n    args: [DOCUMENT]\n  }]\n}, {\n  type: undefined,\n  decorators: [{\n    type: Inject,\n    args: [PLATFORM_ID]\n  }]\n}];\n\nScrollToService = __decorate([__param(0, Inject(DOCUMENT)), __param(1, Inject(PLATFORM_ID))], ScrollToService);\nlet ScrollToDirective = class ScrollToDirective {\n  constructor(elementRef, scrollToService, renderer2) {\n    this.elementRef = elementRef;\n    this.scrollToService = scrollToService;\n    this.renderer2 = renderer2;\n    this.ngxScrollTo = DEFAULTS.target;\n    this.ngxScrollToEvent = DEFAULTS.action;\n    this.ngxScrollToDuration = DEFAULTS.duration;\n    this.ngxScrollToEasing = DEFAULTS.easing;\n    this.ngxScrollToOffset = DEFAULTS.offset;\n    this.ngxScrollToOffsetMap = DEFAULTS.offsetMap;\n  }\n  /**\n   * Angular Lifecycle Hook - After View Init\n   *\n   * @todo Implement Subscription for Events\n   *\n   * @returns void\n   */\n\n\n  ngAfterViewInit() {\n    // Test Event Support\n    if (EVENTS.indexOf(this.ngxScrollToEvent) === -1) {\n      throw new Error(`Unsupported Event '${this.ngxScrollToEvent}'`);\n    } // Listen for the trigger...\n\n\n    this.renderer2.listen(this.elementRef.nativeElement, this.ngxScrollToEvent, event => {\n      this.options = {\n        target: this.ngxScrollTo,\n        duration: this.ngxScrollToDuration,\n        easing: this.ngxScrollToEasing,\n        offset: this.ngxScrollToOffset,\n        offsetMap: this.ngxScrollToOffsetMap\n      };\n      this.scrollToService.scrollTo(this.options);\n    });\n  }\n\n};\n\nScrollToDirective.ɵfac = function ScrollToDirective_Factory(t) {\n  return new (t || ScrollToDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ScrollToService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n};\n\nScrollToDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: ScrollToDirective,\n  selectors: [[\"\", \"ngxScrollTo\", \"\"]],\n  inputs: {\n    ngxScrollTo: \"ngxScrollTo\",\n    ngxScrollToEvent: \"ngxScrollToEvent\",\n    ngxScrollToDuration: \"ngxScrollToDuration\",\n    ngxScrollToEasing: \"ngxScrollToEasing\",\n    ngxScrollToOffset: \"ngxScrollToOffset\",\n    ngxScrollToOffsetMap: \"ngxScrollToOffsetMap\"\n  }\n});\n\nScrollToDirective.ctorParameters = () => [{\n  type: ElementRef\n}, {\n  type: ScrollToService\n}, {\n  type: Renderer2\n}];\n\n__decorate([Input()], ScrollToDirective.prototype, \"ngxScrollTo\", void 0);\n\n__decorate([Input()], ScrollToDirective.prototype, \"ngxScrollToEvent\", void 0);\n\n__decorate([Input()], ScrollToDirective.prototype, \"ngxScrollToDuration\", void 0);\n\n__decorate([Input()], ScrollToDirective.prototype, \"ngxScrollToEasing\", void 0);\n\n__decorate([Input()], ScrollToDirective.prototype, \"ngxScrollToOffset\", void 0);\n\n__decorate([Input()], ScrollToDirective.prototype, \"ngxScrollToOffsetMap\", void 0);\n\nvar ScrollToModule_1;\n/** Scroll To Module */\n\nlet ScrollToModule = ScrollToModule_1 = class ScrollToModule {\n  /**\n   * Guaranteed singletons for provided Services across App.\n   *\n   * @return          An Angular Module with Providers\n   */\n  static forRoot() {\n    return {\n      ngModule: ScrollToModule_1,\n      providers: [ScrollToService]\n    };\n  }\n\n};\n\nScrollToModule.ɵfac = function ScrollToModule_Factory(t) {\n  return new (t || ScrollToModule)();\n};\n\nScrollToModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: ScrollToModule\n});\nScrollToModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrollToService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrollToDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxScrollTo]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ScrollToService\n    }, {\n      type: ɵngcc0.Renderer2\n    }];\n  }, {\n    ngxScrollTo: [{\n      type: Input\n    }],\n    ngxScrollToEvent: [{\n      type: Input\n    }],\n    ngxScrollToDuration: [{\n      type: Input\n    }],\n    ngxScrollToEasing: [{\n      type: Input\n    }],\n    ngxScrollToOffset: [{\n      type: Input\n    }],\n    ngxScrollToOffsetMap: [{\n      type: Input\n    }]\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrollToModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [ScrollToDirective],\n      exports: [ScrollToDirective]\n    }]\n  }], null, null);\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ScrollToModule, {\n    declarations: [ScrollToDirective],\n    exports: [ScrollToDirective]\n  });\n})();\n/*\n * Public API Surface of ngx-scroll-to\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ScrollToDirective, ScrollToModule, ScrollToService };","map":{"version":3,"names":["__decorate","__param","ElementRef","Inject","PLATFORM_ID","Injectable","Renderer2","Input","Directive","NgModule","isPlatformBrowser","DOCUMENT","ReplaySubject","throwError","ɵngcc0","DEFAULTS","target","action","duration","easing","offset","offsetMap","Map","ɵ0","time","ɵ1","ɵ2","ɵ3","ɵ4","ɵ5","ɵ6","ɵ7","ɵ8","ɵ9","ɵ10","ɵ11","ɵ12","Math","pow","sin","PI","EASING","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeOutElastic","EVENTS","stripHash","value","substring","isString","String","isWindow","container","window","isElementRef","isNativeElement","HTMLElement","isNumber","isNaN","parseFloat","isFinite","ScrollToAnimation","constructor","listenerTarget","to","options","isBrowser","loop","timeLapsed","tick","percentage","position","startPosition","distance","lastPosition","stop","source$","next","scrollTo","floor","scrollTop","interval","windowScrollTop","pageYOffset","document","documentElement","body","getBoundingClientRect","top","directionalDistance","abs","mappedOffset","forEach","key","innerWidth","start","clearInterval","setInterval","asObservable","complete","ScrollToService","platformId","interruptiveEvents","mergedConfigOptions","Object","assign","animation","targetNode","getNode","getContainer","getListenerTarget","scrollY","onInterrupt","addInterruptiveEventListeners","animation$","subscribeToAnimation","subscription","subscribe","removeInterruptiveEventListeners","unsubscribe","getFirstScrollableParent","handler","event","addEventListener","supportPassive","passive","supportsPassive","opts","defineProperty","get","removeEventListener","e","events","nativeElement","style","getComputedStyle","overflowRegex","parent","parentElement","overflow","overflowY","test","tagName","id","allowBodyTag","getElementById","isDocumentBody","element","toUpperCase","ɵfac","ScrollToService_Factory","t","ɵɵinject","ɵprov","ɵɵdefineInjectable","token","factory","ctorParameters","type","undefined","decorators","args","ScrollToDirective","elementRef","scrollToService","renderer2","ngxScrollTo","ngxScrollToEvent","ngxScrollToDuration","ngxScrollToEasing","ngxScrollToOffset","ngxScrollToOffsetMap","ngAfterViewInit","indexOf","Error","listen","ScrollToDirective_Factory","ɵɵdirectiveInject","ɵdir","ɵɵdefineDirective","selectors","inputs","prototype","ScrollToModule_1","ScrollToModule","forRoot","ngModule","providers","ScrollToModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","ngDevMode","ɵsetClassMetadata","selector","declarations","exports","ngJitMode","ɵɵsetNgModuleScope"],"sources":["/home/dell/Enigma Camp/FrontEnd/Angular/livecode-news-asix/node_modules/@nicky-lenaers/ngx-scroll-to/__ivy_ngcc__/fesm2015/nicky-lenaers-ngx-scroll-to.js"],"sourcesContent":["import { __decorate, __param } from 'tslib';\nimport { ElementRef, Inject, PLATFORM_ID, Injectable, Renderer2, Input, Directive, NgModule } from '@angular/core';\nimport { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport { ReplaySubject, throwError } from 'rxjs';\n\n/** Default values for Component Input */\nimport * as ɵngcc0 from '@angular/core';\nconst DEFAULTS = {\n    target: null,\n    action: 'click',\n    duration: 650,\n    easing: 'easeInOutQuad',\n    offset: 0,\n    offsetMap: new Map()\n};\nconst ɵ0 = (time) => {\n    return time * time;\n}, ɵ1 = (time) => {\n    return time * (2 - time);\n}, ɵ2 = (time) => {\n    return time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time;\n}, ɵ3 = (time) => {\n    return time * time * time;\n}, ɵ4 = (time) => {\n    return (--time) * time * time + 1;\n}, ɵ5 = (time) => {\n    return time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;\n}, ɵ6 = (time) => {\n    return time * time * time * time;\n}, ɵ7 = (time) => {\n    return 1 - (--time) * time * time * time;\n}, ɵ8 = (time) => {\n    return time < 0.5 ? 8 * time * time * time * time : 1 - 8 * (--time) * time * time * time;\n}, ɵ9 = (time) => {\n    return time * time * time * time * time;\n}, ɵ10 = (time) => {\n    return 1 + (--time) * time * time * time * time;\n}, ɵ11 = (time) => {\n    return time < 0.5 ? 16 * time * time * time * time * time : 1 + 16 * (--time) * time * time * time * time;\n}, ɵ12 = (time) => {\n    return Math.pow(2, -10 * time) * Math.sin((time - 1 / 4) * (2 * Math.PI) / 1) + 1;\n};\n/** Easing Colleciton */\nconst EASING = {\n    easeInQuad: ɵ0,\n    easeOutQuad: ɵ1,\n    easeInOutQuad: ɵ2,\n    easeInCubic: ɵ3,\n    easeOutCubic: ɵ4,\n    easeInOutCubic: ɵ5,\n    easeInQuart: ɵ6,\n    easeOutQuart: ɵ7,\n    easeInOutQuart: ɵ8,\n    easeInQuint: ɵ9,\n    easeOutQuint: ɵ10,\n    easeInOutQuint: ɵ11,\n    easeOutElastic: ɵ12\n};\n/**\n * Set of allowed events as triggers\n * for the Animation to start.\n */\nconst EVENTS = [\n    'click',\n    'mouseenter',\n    'mouseover',\n    'mousedown',\n    'mouseup',\n    'dblclick',\n    'contextmenu',\n    'wheel',\n    'mouseleave',\n    'mouseout'\n];\n/**\n * Strip hash (#) from value.\n *\n * @param value \t\t\t\tThe given string value\n * @returns \t\t\t\t\tThe stripped string value\n */\nfunction stripHash(value) {\n    return value.substring(0, 1) === '#' ? value.substring(1) : value;\n}\n/**\n * Test if a given value is a string.\n *\n * @param value \t\t\t\t\tThe given value\n * @returns \t\t\t\t\t\tWhether the given value is a string\n */\nfunction isString(value) {\n    return typeof value === 'string' || value instanceof String;\n}\n/**\n * Test if a given Element is the Window.\n *\n * @param container \t\t\t\tThe given Element\n * @returns \t\t\t\t\t\tWhether the given Element is Window\n */\nfunction isWindow(container) {\n    return container === window;\n}\n/**\n * Test if a given value is of type ElementRef.\n *\n * @param value \t\t\t\t\tThe given value\n * @returns               Whether the given value is a number\n */\nfunction isElementRef(value) {\n    return value instanceof ElementRef;\n}\n/**\n * Whether or not the given value is a Native Element.\n *\n * @param value           The given value\n * @returns               Whether or not the value is a Native Element\n */\nfunction isNativeElement(value) {\n    return value instanceof HTMLElement;\n}\n/**\n * Test if a given value is type number.\n *\n * @param value \t\t\t\t\tThe given value\n * @returns \t\t\t\t\t\tWhether the given value is a number\n */\nfunction isNumber(value) {\n    return !isNaN(parseFloat(value)) && isFinite(value);\n}\n\n/** Scroll To Animation */\nclass ScrollToAnimation {\n    /**\n     * Class Constructor.\n     *\n     * @param container            The Container\n     * @param listenerTarget       The Element that listens for DOM Events\n     * @param isWindow             Whether or not the listener is the Window\n     * @param to                   Position to scroll to\n     * @param options              Additional options for scrolling\n     * @param isBrowser            Whether or not execution runs in the browser\n     *                              (as opposed to the server)\n     */\n    constructor(container, listenerTarget, isWindow, to, options, isBrowser) {\n        this.container = container;\n        this.listenerTarget = listenerTarget;\n        this.isWindow = isWindow;\n        this.to = to;\n        this.options = options;\n        this.isBrowser = isBrowser;\n        /** Recursively loop over the Scroll Animation */\n        this.loop = () => {\n            this.timeLapsed += this.tick;\n            this.percentage = (this.timeLapsed / this.options.duration);\n            this.percentage = (this.percentage > 1) ? 1 : this.percentage;\n            // Position Update\n            this.position = this.startPosition +\n                ((this.startPosition - this.to <= 0 ? 1 : -1) *\n                    this.distance *\n                    EASING[this.options.easing](this.percentage));\n            if (this.lastPosition !== null && this.position === this.lastPosition) {\n                this.stop();\n            }\n            else {\n                this.source$.next(this.position);\n                this.isWindow\n                    ? this.listenerTarget.scrollTo(0, Math.floor(this.position))\n                    : this.container.scrollTop = Math.floor(this.position);\n                this.lastPosition = this.position;\n            }\n        };\n        this.tick = 16;\n        this.interval = null;\n        this.lastPosition = null;\n        this.timeLapsed = 0;\n        this.windowScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\n        if (!this.container) {\n            this.startPosition = this.windowScrollTop;\n        }\n        else {\n            this.startPosition = this.isWindow ? this.windowScrollTop : this.container.scrollTop;\n        }\n        // Correction for Starting Position of nested HTML Elements\n        if (this.container && !this.isWindow) {\n            this.to = this.to - this.container.getBoundingClientRect().top + this.startPosition;\n        }\n        // Set Distance\n        const directionalDistance = this.startPosition - this.to;\n        this.distance = this.container ? Math.abs(this.startPosition - this.to) : this.to;\n        this.mappedOffset = this.options.offset;\n        // Set offset from Offset Map\n        if (this.isBrowser) {\n            this.options\n                .offsetMap\n                .forEach((value, key) => this.mappedOffset = window.innerWidth > key ? value : this.mappedOffset);\n        }\n        this.distance += this.mappedOffset * (directionalDistance <= 0 ? 1 : -1);\n        this.source$ = new ReplaySubject();\n    }\n    /**\n     * Start the new Scroll Animation.\n     *\n     * @returns         Observable containing a number\n     */\n    start() {\n        clearInterval(this.interval);\n        this.interval = setInterval(this.loop, this.tick);\n        return this.source$.asObservable();\n    }\n    /**\n     * Stop the current Scroll Animation Loop.\n     *\n     * @param force          Force to stop the Animation Loop\n     * @returns               Void\n     */\n    stop() {\n        clearInterval(this.interval);\n        this.interval = null;\n        this.source$.complete();\n    }\n}\n\n/**\n * The Scroll To Service handles starting, interrupting\n * and ending the actual Scroll Animation. It provides\n * some utilities to find the proper HTML Element on a\n * given page to setup Event Listeners and calculate\n * distances for the Animation.\n */\nlet ScrollToService = class ScrollToService {\n    /**\n     * Construct and setup required paratemeters.\n     *\n     * @param document         A Reference to the Document\n     * @param platformId       Angular Platform ID\n     */\n    constructor(document, platformId) {\n        this.document = document;\n        this.platformId = platformId;\n        this.interruptiveEvents = ['mousewheel', 'DOMMouseScroll', 'touchstart'];\n    }\n    /**\n     * Target an Element to scroll to. Notice that the `TimeOut` decorator\n     * ensures the executing to take place in the next Angular lifecycle.\n     * This allows for scrolling to elements that are e.g. initially hidden\n     * by means of `*ngIf`, but ought to be scrolled to eventually.\n     *\n     * @todo type 'any' in Observable should become custom type like 'ScrollToEvent' (base class), see issue comment:\n     *  - https://github.com/nicky-lenaers/ngx-scroll-to/issues/10#issuecomment-317198481\n     *\n     * @param options         Configuration Object\n     * @returns               Observable\n     */\n    scrollTo(options) {\n        if (!isPlatformBrowser(this.platformId)) {\n            return new ReplaySubject().asObservable();\n        }\n        return this.start(options);\n    }\n    /**\n     * Start a new Animation.\n     *\n     * @todo Emit proper events from subscription\n     *\n     * @param options         Configuration Object\n     * @returns               Observable\n     */\n    start(options) {\n        // Merge config with default values\n        const mergedConfigOptions = Object.assign(Object.assign({}, DEFAULTS), options);\n        if (this.animation) {\n            this.animation.stop();\n        }\n        const targetNode = this.getNode(mergedConfigOptions.target);\n        if (mergedConfigOptions.target && !targetNode) {\n            return throwError('Unable to find Target Element');\n        }\n        const container = this.getContainer(mergedConfigOptions, targetNode);\n        if (mergedConfigOptions.container && !container) {\n            return throwError('Unable to find Container Element');\n        }\n        const listenerTarget = this.getListenerTarget(container) || window;\n        let to = container ? container.getBoundingClientRect().top : 0;\n        if (targetNode) {\n            to = isWindow(listenerTarget) ?\n                window.scrollY + targetNode.getBoundingClientRect().top :\n                targetNode.getBoundingClientRect().top;\n        }\n        // Create Animation\n        this.animation = new ScrollToAnimation(container, listenerTarget, isWindow(listenerTarget), to, mergedConfigOptions, isPlatformBrowser(this.platformId));\n        const onInterrupt = () => this.animation.stop();\n        this.addInterruptiveEventListeners(listenerTarget, onInterrupt);\n        // Start Animation\n        const animation$ = this.animation.start();\n        this.subscribeToAnimation(animation$, listenerTarget, onInterrupt);\n        return animation$;\n    }\n    /**\n     * Subscribe to the events emitted from the Scrolling\n     * Animation. Events might be used for e.g. unsubscribing\n     * once finished.\n     *\n     * @param animation$              The Animation Observable\n     * @param listenerTarget          The Listener Target for events\n     * @param onInterrupt             The handler for Interruptive Events\n     * @returns                       Void\n     */\n    subscribeToAnimation(animation$, listenerTarget, onInterrupt) {\n        const subscription = animation$\n            .subscribe(() => {\n        }, () => {\n        }, () => {\n            this.removeInterruptiveEventListeners(this.interruptiveEvents, listenerTarget, onInterrupt);\n            subscription.unsubscribe();\n        });\n    }\n    /**\n     * Get the container HTML Element in which\n     * the scrolling should happen.\n     *\n     * @param options         The Merged Configuration Object\n     * @param targetNode    the targeted HTMLElement\n     */\n    getContainer(options, targetNode) {\n        let container = null;\n        if (options.container) {\n            container = this.getNode(options.container, true);\n        }\n        else if (targetNode) {\n            container = this.getFirstScrollableParent(targetNode);\n        }\n        return container;\n    }\n    /**\n     * Add listeners for the Animation Interruptive Events\n     * to the Listener Target.\n     *\n     * @param events            List of events to listen to\n     * @param listenerTarget    Target to attach the listener on\n     * @param handler           Handler for when the listener fires\n     * @returns                 Void\n     */\n    addInterruptiveEventListeners(listenerTarget, handler) {\n        if (!listenerTarget) {\n            listenerTarget = window;\n        }\n        this.interruptiveEvents\n            .forEach(event => listenerTarget\n            .addEventListener(event, handler, this.supportPassive() ? { passive: true } : false));\n    }\n    /**\n     * Feature-detect support for passive event listeners.\n     *\n     * @returns       Whether or not passive event listeners are supported\n     */\n    supportPassive() {\n        let supportsPassive = false;\n        try {\n            const opts = Object.defineProperty({}, 'passive', {\n                get: () => {\n                    supportsPassive = true;\n                }\n            });\n            window.addEventListener('testPassive', null, opts);\n            window.removeEventListener('testPassive', null, opts);\n        }\n        catch (e) {\n        }\n        return supportsPassive;\n    }\n    /**\n     * Remove listeners for the Animation Interrupt Event from\n     * the Listener Target. Specifying the correct handler prevents\n     * memory leaks and makes the allocated memory available for\n     * Garbage Collection.\n     *\n     * @param events            List of Interruptive Events to remove\n     * @param listenerTarget    Target to attach the listener on\n     * @param handler           Handler for when the listener fires\n     * @returns                 Void\n     */\n    removeInterruptiveEventListeners(events, listenerTarget, handler) {\n        if (!listenerTarget) {\n            listenerTarget = window;\n        }\n        events.forEach(event => listenerTarget.removeEventListener(event, handler));\n    }\n    /**\n     * Find the first scrollable parent Node of a given\n     * Element. The DOM Tree gets searched upwards\n     * to find this first scrollable parent. Parents might\n     * be ignored by CSS styles applied to the HTML Element.\n     *\n     * @param nativeElement     The Element to search the DOM Tree upwards from\n     * @returns                 The first scrollable parent HTML Element\n     */\n    getFirstScrollableParent(nativeElement) {\n        let style = window.getComputedStyle(nativeElement);\n        const overflowRegex = /(auto|scroll|overlay)/;\n        if (style.position === 'fixed') {\n            return null;\n        }\n        let parent = nativeElement;\n        while (parent.parentElement) {\n            parent = parent.parentElement;\n            style = window.getComputedStyle(parent);\n            if (style.position === 'absolute'\n                || style.overflow === 'hidden'\n                || style.overflowY === 'hidden') {\n                continue;\n            }\n            if (overflowRegex.test(style.overflow + style.overflowY)\n                || parent.tagName === 'BODY') {\n                return parent;\n            }\n        }\n        return null;\n    }\n    /**\n     * Get the Target Node to scroll to.\n     *\n     * @param id              The given ID of the node, either a string or\n     *                        an element reference\n     * @param allowBodyTag    Indicate whether or not the Document Body is\n     *                        considered a valid Target Node\n     * @returns               The Target Node to scroll to\n     */\n    getNode(id, allowBodyTag = false) {\n        let targetNode;\n        if (isString(id)) {\n            if (allowBodyTag && (id === 'body' || id === 'BODY')) {\n                targetNode = this.document.body;\n            }\n            else {\n                targetNode = this.document.getElementById(stripHash(id));\n            }\n        }\n        else if (isNumber(id)) {\n            targetNode = this.document.getElementById(String(id));\n        }\n        else if (isElementRef(id)) {\n            targetNode = id.nativeElement;\n        }\n        else if (isNativeElement(id)) {\n            targetNode = id;\n        }\n        return targetNode;\n    }\n    /**\n     * Retrieve the Listener target. This Listener Target is used\n     * to attach Event Listeners on. In case of the target being\n     * the Document Body, we need the actual `window` to listen\n     * for events.\n     *\n     * @param container           The HTML Container element\n     * @returns                   The Listener Target to attach events on\n     */\n    getListenerTarget(container) {\n        if (!container) {\n            return null;\n        }\n        return this.isDocumentBody(container) ? window : container;\n    }\n    /**\n     * Test if a given HTML Element is the Document Body.\n     *\n     * @param element             The given HTML Element\n     * @returns                   Whether or not the Element is the\n     *                            Document Body Element\n     */\n    isDocumentBody(element) {\n        return element.tagName.toUpperCase() === 'BODY';\n    }\n};\nScrollToService.ɵfac = function ScrollToService_Factory(t) { return new (t || ScrollToService)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(PLATFORM_ID)); };\nScrollToService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ScrollToService, factory: function (t) { return ScrollToService.ɵfac(t); } });\nScrollToService.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\n];\nScrollToService = __decorate([ __param(0, Inject(DOCUMENT)),\n    __param(1, Inject(PLATFORM_ID))\n], ScrollToService);\n\nlet ScrollToDirective = class ScrollToDirective {\n    constructor(elementRef, scrollToService, renderer2) {\n        this.elementRef = elementRef;\n        this.scrollToService = scrollToService;\n        this.renderer2 = renderer2;\n        this.ngxScrollTo = DEFAULTS.target;\n        this.ngxScrollToEvent = DEFAULTS.action;\n        this.ngxScrollToDuration = DEFAULTS.duration;\n        this.ngxScrollToEasing = DEFAULTS.easing;\n        this.ngxScrollToOffset = DEFAULTS.offset;\n        this.ngxScrollToOffsetMap = DEFAULTS.offsetMap;\n    }\n    /**\n     * Angular Lifecycle Hook - After View Init\n     *\n     * @todo Implement Subscription for Events\n     *\n     * @returns void\n     */\n    ngAfterViewInit() {\n        // Test Event Support\n        if (EVENTS.indexOf(this.ngxScrollToEvent) === -1) {\n            throw new Error(`Unsupported Event '${this.ngxScrollToEvent}'`);\n        }\n        // Listen for the trigger...\n        this.renderer2.listen(this.elementRef.nativeElement, this.ngxScrollToEvent, (event) => {\n            this.options = {\n                target: this.ngxScrollTo,\n                duration: this.ngxScrollToDuration,\n                easing: this.ngxScrollToEasing,\n                offset: this.ngxScrollToOffset,\n                offsetMap: this.ngxScrollToOffsetMap\n            };\n            this.scrollToService.scrollTo(this.options);\n        });\n    }\n};\nScrollToDirective.ɵfac = function ScrollToDirective_Factory(t) { return new (t || ScrollToDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ScrollToService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };\nScrollToDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ScrollToDirective, selectors: [[\"\", \"ngxScrollTo\", \"\"]], inputs: { ngxScrollTo: \"ngxScrollTo\", ngxScrollToEvent: \"ngxScrollToEvent\", ngxScrollToDuration: \"ngxScrollToDuration\", ngxScrollToEasing: \"ngxScrollToEasing\", ngxScrollToOffset: \"ngxScrollToOffset\", ngxScrollToOffsetMap: \"ngxScrollToOffsetMap\" } });\nScrollToDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: ScrollToService },\n    { type: Renderer2 }\n];\n__decorate([\n    Input()\n], ScrollToDirective.prototype, \"ngxScrollTo\", void 0);\n__decorate([\n    Input()\n], ScrollToDirective.prototype, \"ngxScrollToEvent\", void 0);\n__decorate([\n    Input()\n], ScrollToDirective.prototype, \"ngxScrollToDuration\", void 0);\n__decorate([\n    Input()\n], ScrollToDirective.prototype, \"ngxScrollToEasing\", void 0);\n__decorate([\n    Input()\n], ScrollToDirective.prototype, \"ngxScrollToOffset\", void 0);\n__decorate([\n    Input()\n], ScrollToDirective.prototype, \"ngxScrollToOffsetMap\", void 0);\n\nvar ScrollToModule_1;\n/** Scroll To Module */\nlet ScrollToModule = ScrollToModule_1 = class ScrollToModule {\n    /**\n     * Guaranteed singletons for provided Services across App.\n     *\n     * @return          An Angular Module with Providers\n     */\n    static forRoot() {\n        return {\n            ngModule: ScrollToModule_1,\n            providers: [\n                ScrollToService\n            ]\n        };\n    }\n};\nScrollToModule.ɵfac = function ScrollToModule_Factory(t) { return new (t || ScrollToModule)(); };\nScrollToModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ScrollToModule });\nScrollToModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrollToService, [{\n        type: Injectable\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }]; }, null); })();\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrollToDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[ngxScrollTo]'\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ScrollToService }, { type: ɵngcc0.Renderer2 }]; }, { ngxScrollTo: [{\n            type: Input\n        }], ngxScrollToEvent: [{\n            type: Input\n        }], ngxScrollToDuration: [{\n            type: Input\n        }], ngxScrollToEasing: [{\n            type: Input\n        }], ngxScrollToOffset: [{\n            type: Input\n        }], ngxScrollToOffsetMap: [{\n            type: Input\n        }] }); })();\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrollToModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [\n                    ScrollToDirective\n                ],\n                exports: [\n                    ScrollToDirective\n                ]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ScrollToModule, { declarations: [ScrollToDirective], exports: [ScrollToDirective] }); })();\n\n/*\n * Public API Surface of ngx-scroll-to\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ScrollToDirective, ScrollToModule, ScrollToService };\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}